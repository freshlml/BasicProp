第一: 内置基础核心类型
    数字
        整数<class 'int'>, python没有限制其大小; 十进制数:123654; 二进制数:0b11011; 八进制数:0o71011; 十六进制数:0xabc1209
        浮点数<class 'float'>, 8个字节存储: 1位符号位，11位指数，52位有效数字，即双精度浮点型; 1.09; 1.09E100; 3.14e-10
        decimal
            Decimal, 存储精确; 计算确定; 指定小数保存位数; 舍入或者截断规则
        fraction
            Fraction, Fraction(1, 3)#分子，分母: 存储精确; 计算确定; 指定小数保存位数; 舍入或者截断规则
        复数       3+4j, 3.0+4.0j

    字符串
        <class 'str'> '字符串'; "字符串"; b'a\xo'
        s[index]按索引取值, s[i:j]按[i,j)取值, i默认值0, j默认值len(s), index/i/j可以取负数, 其意义为 len(s)+index/i/j, 不能按索引修改s[0]='3'将error
        s1 + s2,返回<class 'str'> 合并的字符串; s1 * 8, 返回<class 'str'> s1重复8次的字符串    运算符重载...
        字符串对象的不可变(类比): 一旦定义一个字符串，如s='字符串',则不能通过位置索引改变字符串，如s[0]='3'将error
                            但变量s可以指向一个新的字符串,如s='另一个字符串',旧的'字符串'对象会被清理
                            <class 'str'>类型定义了很多方法如，find,replace,split等
                            注意的是replace等方法返回的是一个新的字符串对象
        可迭代;
        查看说明: dir(''), help(''.replace)
        如何调出源码?

    元组
        元素任意类型; 有序; 不可修改; 是linked还是array??
        <class 'tuple'>, (1, "2", [1, 2], ("3", 2)), 使用()定义元组
        tp[index]按索引取值, tp[i:j]按[i, j)取值，i默认值0，j默认值len(tp), index/i/j可以取负数, 其意义为 len(tp)+index/i/j, index>len(lst): lst[len(lst)] or lst[1:len(lst)+100]
        嵌套;
        可迭代

    列表
        元素任意类型; 有序性; 可修改; 是linked还是array??
        <class 'list'>, [1, '字符串', ['2', '子列表']], 使用[]定义列表
        lst[index]按索引取值, lst[i:j]按[i, j)取值，i默认值0，j默认值len(lst), index/i/j可以取负数, 其意义为 len(lst)+index/i/j, index>len(lst): lst[len(lst)] or lst[1:len(lst)+100]
        修改:lst[2].append('append')
        嵌套; 二位数组m = [[1, 2, 3],
                         [4, 5, 6],
                         [7, 8, 9]]   m[0]-->[1,2,3], m[1][2]-->6
        相等性:  l1 = [1, [2], 3]
                l2 = [1, [3], 2]
                print(l1 < l2)  # True, 深度优先遍历
        可迭代;
        列表解析表达式: col = [per[1] for per in m]
        type(lst) == list or isinstance(type(lst))

    字典
        key类型:hashable type,value任意类型; 无序性; 可修改
        <class 'dict'>, {"key1": "value", "key2": ['list']} (使用{}定义字典)
        key的hash运算找桶，hash碰撞时比较key的值，如果key值相等，覆盖(逻辑和HashMap一致)
        d[key]根据key取值; 支持修改,d[key] = value: 覆盖或者插入
        嵌套;
        可迭代;
        列表解析表达式

    集合
        元素类型:hashable type; 无序性; 可修改
        <class 'set'>, {1, '2'}  (使用{}定义集合)
        可通过add等方法修改
        可迭代

    None
        l = None
        print(type(l))   //<class 'NoneType'>
        lst = [None, None]
        print(len(lst))   //2
        即python版null
    布尔
        boolean常量: True,False
        b = True
        print(b)        //True
        print(type(b))  //<class 'bool'>



第二: 对象引用
python中没有基本类型，int也是一种类类型: <class 'int'>，正因为<class 'int'>不是基本类型(基本类型的int有大小限制如4字节，why基本类型有小大限制,@see如下)，他存放的整数值才可以是无限大的
<class 'int'>、<class 'str'> 不可变
a = 1           # a--->1  变量a指向  int对象(值为1)
b = a           # b--->1  变量b指向  a指向的int对象
a = a + 2       # a--->3  根据变量a取值+2得到3, 创建int对象保存3{python中int类型是不可变的，所以每次计算都会创建新的int对象}, 变量a指向int对象(值为3)

print(a)  # 3
print(b)  # 1


java中的int是基本类型，不是引用的形式
int a = 1;      # 线程栈中声明变量a，开辟int类型空间，存放1
int b = a;      # 线程栈中声明变量b，开辟int类型空间，存放1
a = a + 2;      # 根据变量a取值+2得到3，存入变量a的空间

print(a)  # 3
print(b)  # 1


java中的相同机制
String是类类型，并且是不可变的
String a = "abc";   # 变量a指向 字符串对象("abc")
String b = a;       # 变量b指向 a指向的字符串对象
a = a + "--";       # 取变量a的值+"--"得到"abc--", 创建字符串对象("abc--"){字符串对象是不可变的，所有会创建新的字符串对象}, 变量a指向字符串对象("abc--")

print(a);  # abc
print(b);  # abc--


基本类型的设计理念
1、java中基本类型: 类型和大小
   eg，int a = 1; # 线程栈中声明变量a，开辟int类型空间（空间有大小规定,4字节），存放1
        a变量  ----
             | 1  |
              ----

   eg，class Obj {
          int a;
          OtherObj other;
          public Obj(int a) {
            this.a = a;
            other = new OtherObj();
          }
      }
      Obj obj = new Obj(1);  # 内存中创建Obj类型的对象，线程栈中声明变量obj(固定大小如2字节，存放引用值)，指向创建的对象
      obj变量  ----                Obj类型对象 {
             |引用 | ---------->            int a:            ----     Obj类型对象的内存空间中声明变量a，开辟int类型空间（空间有大小规定,4字节），存放1
              ----                                          | 1  |
                                                             ----
                                           OtherObj other;   Obj类型对象的内存空间中声明变量other(固定大小如2字节，存放引用值)，指向OtherObj类型的对象
                                  }
2、python中没有基本类型
   eg， a = 1  # 变量a存放引用值，引用指向class<'int'>类型的对象
   eg，class Obj
       obj = new Obj  # 变量obj存放引用值，引用指向class<'Obj'>类型的对象


3、why基本类型有小大限制 ？
考虑如下代码 method(int i, Obj obj)，这段代码中，如果不知道int的大小，就没办法声明int的内存空间了
                                   然而，Obj这里传递的是引用值(引用值大小一定)


第三: 字符串与编码

@ see chapter2-7.py

s = "中h𝄞1"
变量s存引用值  --->  class<'str'>类型对象{
                        [
                            引用          -------> class<'int'>类型对象（该对象的内存空间中开辟一块空间存unicode字符'中'的码点）
                            引用          -------> class<'int'>类型对象（该对象的内存空间中开辟一块空间存unicode字符'h'的码点）
                            引用          -------> class<'int'>类型对象（该对象的内存空间中开辟一块空间存unicode字符'𝄞'的码点）
                        ]
                   }


第四: list、对象引用，嵌套时要特别注意

lst = [1, ["1", 2], "123"]
变量lst存引用值 --->  class<'list'>类型对象{
                        [
                            引用         -------> class<'int'>类型对象（该对象的内存空间中开辟一块空间存数字1）
                            引用         -------> class<'list'>类型对象
                            引用         -------> class<'str'>类型对象
                        ]
                    }

# 只是拷贝引用值(所以当对象是可变的时候要特别注意)
t = 1
lst_n = [1, 2]
lst = [t, lst_n]        # t、lst_n的引用值拿过来了，并不是数据拷贝

print(t is lst[0])      # True
print(lst_n is lst[1])  # True

# 重复，合并，分片只是拷贝引用值(所以当对象是可变的时候要特别注意)
lst = ['123', [1, 2]]
x = lst * 2           # 重复: 引用值拷贝
print(x[0] is lst[0])  # True
print(x[0] is x[2])    # True
print(x[1] is lst[1])  # True
print(x[1] is x[3])    # True
print(x)               # ['123', [1, 2], '123', [1, 2]]

lst[0] = '321'  # 因为字符串不可变，lst[0]会指向'321', x[0]、x[2]还是指向'123'
lst[1][0] = 0   # lst[1]指向列表对象(x[1]、x[3]也指向该列表对象)，lst[1][0]=0: 将lst[1]指向的列表对象中的第一个元素指向对象0
print(x)               # ['123', [0, 2], '123', [0, 2]]



第五: 文件

@see chapter2-9.py


第六: 序列化

字符串编码解码
  编码: 字符序列编码成字节序列，字节序列用于存储和传输
  解码: 字节序列解码成字符序列
字符串编码解码是序列化概念中的特殊情况


序列化:     对象"序列化"成字节序列，字节序列用于存储和传输
反序列化:   字节序列"反序列化"成对象

json序列化:   对象序列化成json字符串，json字符串在存储和传输时encode成字节序列
json反序列化: json字符串反序列化成对象

@see xy-service-sample


第七: bug
l = [4, 5, 6, [1, 2]]
x = l * 4


